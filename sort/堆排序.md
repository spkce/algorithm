# 堆
堆在形式上是一棵完全二叉树（假设树的高度是h，所有的叶子结点都是在第h层或h-1层）

堆分为两类，大根堆和小根堆：

大根堆：每个结点的值都大于等于其孩子结点的值；
小根堆：每个结点的值都小于等于其孩子结点的值；
堆在形式上是一棵完全二叉树，用数组存储它，不会浪费空间；堆在形式上是一棵完全二叉树（假设树的高度是h，所有的叶子结点都是在第h层或h-1层）

堆分为两类，大根堆和小根堆：

大根堆：每个结点的值都大于等于其孩子结点的值；
小根堆：每个结点的值都小于等于其孩子结点的值；
堆在形式上是一棵完全二叉树，用数组存储它，不会浪费空间；
```
数组：

17 13 6 1 4 2 5

二叉树：
        17
      /    \
    13      6
  /   \   /   \
1     4  2     5

数组中第i个元素的：
父节点位置： floor((i-1)/2) 「向下取整」
左孩子节点位置：2*i+1
右孩子节点位置：2*i+2
```
# 堆排序
## 堆排序的基本思想：
1. 首先建立大根堆或小根堆（从小到大排序建立大根堆；从大到小排序，建立小根堆）
2. 奖堆顶与堆尾元素互换，使剩余元素重新调整为堆。
3. 重复步骤2，直到堆内元素个数为0，即可得到一个有序数组。
## 堆排序的核心步骤：
1. 将数组建立成大根堆或者小根堆，简称数组建堆。
2. 将剩余元算调整成堆，简称堆化

## 堆化 heapify

将堆顶与堆尾元素互换，“自顶向下”不断调整堆内元素位置，使剩余元素重新成堆。（以大根堆为例）该过程存在两个终止条件:1.当前结点的数值比其孩子结点的数值大；2.当前结点是叶子结点；
```
二叉树：
        17                      5                      13
      /    \    取出根节点     /    \     自顶向下      /    \
    13      6   将尾节点放顶   13     6    调整堆      5      6
  /   \   /   \             /   \   /              /   \   /  
1     4  2     5           1     4  2            1     4  2    

数组: 17 13 6 1 4 2 5    5 13 6 1 4 2 5 17      13 5 6 1 4 2 5 17
```
空间复杂度：O(1)
时间复杂度：O(logN)
heapify是从根结点开始，自顶向下调整堆内元素，直至叶子结点。所以，heapify的时间复杂度是：O(logN)，即二叉树的高度。
实例：大根堆的堆化
```c++
//n为堆长度
void heapify(int* nums, int n, int i)
{
	int left = 2*i+1;
	int right = 2*i+2;
	while (left < n) //当前节点存在左孩子
	{
		int right = 2*i+2;
		//左右孩子节点选出最大值
		int son = left;
		if (right < n && nums[left] < nums[right])
		{
			son = right;
		}

		if (nums[son] < nums[i])
		{
			//若当前结点比左右孩子结点数值大，终止堆化过程
			break;
		}
		else
		{
			std::swap(nums[i], nums[son]);
			//调整结点位置，重复步骤2
			i = son;
			left = 2*i+1;
			right = 2*i+2;
		}
	}
}
```
## 数组建堆
有两种方法可以用于“数组建堆”过程。方法1：在空二叉树的基础上，插入元素并调整成堆；方法2：在完全二叉树的基础上，从叶子结点到根结点调整成堆

方法1：插入元素，“自底向上”调整成堆
```
          17                         17                       17       
        /    \                     /    \                   /    \     
      13      6                  13      6                15      6    
    /   \   /   \     ->       /   \   /   \     ->     /   \   /   \  
  1     4  2     5           15     4  2     5        13     4  2     5 
 /                          /                        /                 
15                         1                        1                 
数组: 17 13 6 1 4 2 5 15   17 13 6 15 4 2 5 1       17 15 6 13 4 2 5 1
```
空间复杂度：O(1)
时间复杂度：O(N*logN)
heapInsert过程是自底向上调整堆内元素位置，使之成堆。时间复杂度是O(logN)，即二叉树高度。所以，buildMaxHeap的时间复杂度是：O(N*logN)
```c++
//大根堆
void heapBuildMax1(int* nums, int n)
{
	//方法1：插入元素，自底向上调整成堆
	for (int i = 0; i < n; i++)
	{
		while (i > 0 && nums[i] > nums[(i - 1)/2])
		{
			std::swap(nums[i], nums[(i - 1)/2]);
			i = (i - 1)/2;
		}
		
	}
}
```
方法2：在完全二叉树的基础上，调整成堆
空间复杂度：O(1)
时间复杂度：O(N)
```c++
void heapBuildMax2(int* nums, int n)
{
	//方法2：在完全二叉树的基础上调整成堆
	for (int i = n-1; i >= 0; i--)
	{
		heapify(nums, n, i);
	}
}
```

# 堆排序
“大顶堆”用于升序排列
“小顶堆”用于降序排列

## 堆排序的过程
1.根据拿到的数组构建大顶堆/小顶堆；
2.从堆顶取走元素，放到其应该存在的位置中去。从堆底拿到堆中最后一个元素，放到堆顶，此时这个堆很可能不再合法也就是说不再是一个堆；
3.维护这个堆，通过自己写的方法调整堆中节点结构，让它重新变成一个堆；
4.重复2,3过程，直到堆被取空，此时数组也被完全排列好；

升序排序
```c++
void heapify(int* nums, int n, int i)
{
	int left = 2*i+1;
	int right = 2*i+2;
	while (left < n) //当前节点存在左孩子
	{
		int right = 2*i+2;
		//左右孩子节点选出最大值
		int son = left;
		if (right < n && nums[left] < nums[right])
		{
			son = right;
		}

		if (nums[son] < nums[i])
		{
			//若当前结点比左右孩子结点数值大，终止堆化过程
			break;
		}
		else
		{
			std::swap(nums[i], nums[son]);
			//调整结点位置，重复步骤2
			i = son;
			left = 2*i+1;
			right = 2*i+2;
		}
	}
}

void heapSort(int* nums, int n)
{
	if (nums == nullptr || n == 0)
	{
		return;
	}

	//先进行建堆
	for (int i = n-1; i >= 0; i--)
	{
		heapify(nums, n, i);
	}

	//大根堆将根节点放最后，同时要排序堆的长度减一
	std::swap(nums[0], nums[n-1]);
	n = n - 1;

	//每次拿取根节点到n-1，剩下的再堆化，重复直到完成排序
	while (n>0)
	{
		heapify(nums, n, 0);
		std::swap(nums[0], nums[n-1]);
		n = n - 1;
	}
}
```
空间复杂度：
时间复杂度：
buildMaxHeap1 时间复杂度：O(N*logN)；
buildMaxHeap2 时间复杂度：O(N)；
堆化过程：O(N*logN)
所以，堆排序的时间复杂度是： 
# 前序遍历
根节点—>左子树—>右子树
### 144. 二叉树的前序遍历 - 力扣（LeetCode）
给你二叉树的根节点 root ，返回它节点值的 前序 遍历。
```c++
//递归
class Solution {
public:
    void preorder(TreeNode *root, vector<int> &res) {
        if (root == nullptr) {
            return;
        }
        res.push_back(root->val);
        preorder(root->left, res);
        preorder(root->right, res);
    }

    vector<int> preorderTraversal(TreeNode *root) {
        vector<int> res;
        preorder(root, res);
        return res;
    }
};
```
```c++
//迭代
class Solution {
public:
	vector<int> preorderTraversal(TreeNode* root) {
		vector<int> ans;
		if (!root)
		{
			return ans;
		}
		
		std::stack<TreeNode*> stk;
		stk.push(root);
		while (!stk.empty())
		{
			TreeNode* p = stk.top();stk.pop();
			while (p)
			{
				ans.push_back(p->val);
				if (p->right)
				{
					stk.push(p->right);
				}
				p = p->left;
			}
		}
		return ans;
	}
};
```
# 中序遍历
左子树——根节点——右子树

### 94. 二叉树的中序遍历 - 力扣（LeetCode）
给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。

```c++
//递归
class Solution {
public:
	void inorder(TreeNode* root, vector<int> & out)
	{
		if(!root)
		{
			return;
		}
		inorder(root->left, out);
		out.push_back(root->val);
		inorder(root->right, out);
	}
	vector<int> inorderTraversal(TreeNode* root) {
		vector<int> ans;

		inorder(root, ans);
		return ans;
	}
};
```
```c++
//迭代
class Solution {
public:

    vector<int> inorderTraversal(TreeNode* root) {
		vector<int> ans;
		if (!root)
		{
			return ans;
		}

		std::stack<TreeNode*> stk;

		while (root || !stk.empty())
		{
			while (root)
			{
				stk.push(root);
				root = root->left;
			}

			root = stk.top();
			ans.push_back(root->val);
			stk.pop();
			root = root->right;
		}

		return ans;
    }
};
```
# 后序遍历
左子树——右子树——根节点
### 145. 二叉树的后序遍历  - 力扣（LeetCode）
给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。
```c++
//递归
class Solution {
public:
	void postorder(TreeNode* root, vector<int> & ans)
	{
		if (!root)
		{
			return ;
		}

		postorder(root->left, ans);
		postorder(root->right, ans);
		ans.push_back(root->val);
	}
    vector<int> postorderTraversal(TreeNode* root) {
		vector<int> ans;
		postorder(root, ans);
		return ans;
    }
};
```
```c++
//迭代
class Solution {
public:
    vector<int> postorderTraversal(TreeNode *root) {
        vector<int> res;
        if (root == nullptr) {
            return res;
        }

        stack<TreeNode *> stk;
        TreeNode *prev = nullptr;
        while (root != nullptr || !stk.empty()) {
            while (root != nullptr) {
                stk.emplace(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();
            if (root->right == nullptr || root->right == prev) {
                res.emplace_back(root->val);
                prev = root;
                root = nullptr;
            } else {
                stk.emplace(root);
                root = root->right;
            }
        }
        return res;
    }
};
```
```c++
//Morris 遍历
//1.新建临时节点，令该节点为 root；
//2.如果当前节点的左子节点为空，则遍历当前节点的右子节点；
//3.如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点；
//    如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点，当前节点更新为当前节点的左子节点。
//    如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。倒序输出从当前节点的左子节点到该前驱节点这条路径上的所有节点。当前节点更新为当前节点的右子节点。
//4.重复步骤 2 和步骤 3，直到遍历结束。
class Solution {
public:
    void addPath(vector<int> &vec, TreeNode *node) {
        int count = 0;
        while (node != nullptr) {
            ++count;
            vec.emplace_back(node->val);
            node = node->right;
        }
        reverse(vec.end() - count, vec.end());
    }

    vector<int> postorderTraversal(TreeNode *root) {
        vector<int> res;
        if (root == nullptr) {
            return res;
        }

        TreeNode *p1 = root, *p2 = nullptr;

        while (p1 != nullptr) {
            p2 = p1->left;
            if (p2 != nullptr) {
                while (p2->right != nullptr && p2->right != p1) {
                    p2 = p2->right;
                }
                if (p2->right == nullptr) {
                    p2->right = p1;
                    p1 = p1->left;
                    continue;
                } else {
                    p2->right = nullptr;
                    addPath(res, p1->left);
                }
            }
            p1 = p1->right;
        }
        addPath(res, root);
        return res;
    }
};
```
# 层序遍历

### 102. 二叉树的层序遍历 - 力扣（LeetCode）

给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。

```c++
class Solution {
public:
	vector<vector<int>> levelOrder(TreeNode* root) {
		std::vector<std::vector<int>> ans;
		if (!root)
		{
			return ans;
		}
		std::queue<TreeNode*> que;
		que.push(root);

		while (!que.empty())
		{
			std::vector<int> t;
			for (int i = que.size(); i > 0; i--)
			{
				TreeNode* p = que.front(); 
				t.push_back(p->val);
				que.pop();
				if (p->left != nullptr)
				{
					que.push(p->left);
				}

				if (p->right != nullptr)
				{
					que.push(p->right);
				}
			}
			ans.push_back(t);
		}
		return ans;
	}
};
```
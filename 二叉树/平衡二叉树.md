# 平衡二叉树
### 定义
平衡二叉树（Balanced Binary Tree）是一种二叉排序树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。简单来说，它是一种高度相对平衡的二叉树结构，这种平衡性质使得在树中进行插入、删除和查找等操作的时间复杂度能够维持在一个较好的水平。
### 平衡因子
平衡二叉树中引入了平衡因子（Balance Factor）的概念。平衡因子是指节点的左子树高度减去右子树高度的值。在平衡二叉树中，每个节点的平衡因子只能是 - 1、0 或者 1。例如，对于一个节点，若其左子树高度为 3，右子树高度为 2，那么该节点的平衡因子为3-2=1。
### 结构特点和优势
高度平衡：通过保持树的平衡，可以避免二叉树退化成链表的情况。例如，在普通二叉排序树中，如果插入的元素是有序的，那么树可能会变成一条很长的链表，导致查找、插入和删除操作的时间复杂度从最好情况下的退化成，其中n是树中的节点数。而平衡二叉树通过其平衡机制，能保证树的高度始终维持在的级别。
高效的操作性能：
查找操作：由于树的高度保持在对数级别，查找操作的时间复杂度为。在平衡二叉树中查找一个元素时，类似于在二分查找中，每次比较都能排除树的大约一半的部分，从而快速定位到目标元素。
插入和删除操作：在插入或删除节点后，平衡二叉树会通过一系列的调整操作（如旋转操作）来恢复平衡。虽然插入和删除操作可能会引起树的不平衡，但通过调整，依然可以将操作的时间复杂度维持在。例如，在插入一个新节点后，如果导致了某一节点的平衡因子超出允许范围，就会进行左旋或右旋操作来重新平衡树。
### 常见的平衡二叉树类型
AVL 树（Adelson - Velskii and Landis Tree）：是最早被发明的平衡二叉树。它在插入和删除操作后，通过严格的旋转操作（单旋和双旋）来保证树的平衡。例如，当一个节点的平衡因子变为 2 或 - 2 时，就会触发旋转操作来调整树的结构。
红黑树（Red - Black Tree）：它是一种更宽松的平衡二叉树。红黑树通过将节点标记为红色或黑色，并规定了一系列的性质（如根节点是黑色，红色节点的子节点必须是黑色等）来保证树的平衡。虽然红黑树的平衡程度不如 AVL 树那么严格，但在插入和删除操作后的调整相对简单，在实际应用中也被广泛使用，特别是在一些对插入和删除操作频繁的场景，如操作系统的进程调度、文件系统等。


## 例题

### 110. 平衡二叉树 - 力扣（LeetCode）
给定一个二叉树，判断它是否是平衡二叉树
示例 1：
```
输入：root = [3,9,20,null,null,15,7]
输出：true
```
示例 2：
```
输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
```
示例 3：
```
输入：root = []
输出：true
```

```c++
//自顶向下的递归
//时间复杂度：O(n^2)，其中 n 是二叉树中的节点个数。
//空间复杂度：O(n)，其中 n 是二叉树中的节点个数
class Solution {
public:
    int height(TreeNode* root) {
        if (root == NULL) {
            return 0;
        } else {
            return max(height(root->left), height(root->right)) + 1;
        }
    }

    bool isBalanced(TreeNode* root) {
        if (root == NULL) {
            return true;
        } else {
            return abs(height(root->left) - height(root->right)) <= 1 && isBalanced(root->left) && isBalanced(root->right);
        }
    }
};
```
```c++
//自底向上的递归
//时间复杂度：O(n), 其中 n 是二叉树中的节点个数
//空间复杂度：O(n),其中 n 是二叉树中的节点个数
class Solution {
public:
    int height(TreeNode* root) {
        if (root == NULL) {
            return 0;
        }
        int leftHeight = height(root->left);
        int rightHeight = height(root->right);
        if (leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) > 1) {
            return -1;
        } else {
            return max(leftHeight, rightHeight) + 1;
        }
    }

    bool isBalanced(TreeNode* root) {
        return height(root) >= 0;
    }
};
```
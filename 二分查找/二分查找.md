# 二分查找
我们可以分成三种情况：
1. 朴素的二分查找(最简单,但是基本不涉及)
2. 查找左边界的二分查找
3. 查找右边界的二分查找

第二第三基本是万能的,但细节较多

二分查找框架：
```c++
int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = (right + left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
```
>注意：有的地方会用 left + (right - left) / 2来计算mid,通过变换就会发现这个公式实际上和 (left + right )/ 2是一样的,但是没有left+ right,就避免了数据范围溢出的风险
# 二分查找四种搜索策略
### 1. 首个大于目标值的搜索策略
```c++
/**
 * @brief 返回首个大于target的元素索引，如果不存在，返回数组长度n
 * @param nums: 输入数组
 * @param target: 目标值
 * @return: 目标值索引
*/
int search(vector<int>& nums, int target){
    // 二分查找区间[left, right)，初始为整个区间
    int left = 0;   
    int right = nums.size();
    // 找到首个大于target的值
    while(left < right){
        int mid = left + ((right - left) >> 1);
        if(nums[mid] > target){
            right = mid;    // 找到一个大于target的值，暂存并在左半区间继续查找
        }else{
            left = mid + 1; // 没有找到大于target的值，在右半区间继续查找
        }
    }
    return right;
}
```
### 2. 首个大于等于目标值的搜索策略
```c++
/**
 * @brief 返回首个大于等于target的元素索引，如果不存在，返回数组长度n
 * @param nums: 输入数组
 * @param target: 目标值
 * @return: 目标值索引
*/
int search(vector<int>& nums, int target){
    // 二分查找区间[left, right)，初始为整个区间
    int left = 0;   
    int right = nums.size();
    // 找到首个大于target的值
    while(left < right){
        int mid = left + ((right - left) >> 1);
        if(nums[mid] >= target){
            right = mid;    // 找到一个大于等于target的值，暂存并在左半区间继续查找
        }else{
            left = mid + 1; // 没有找到大于等于target的值，在右半区间继续查找
        }
    }
    return right;
}
```
### 3. 最后小于目标值的搜索策略
```c++
/**
 * @brief 返回最后小于target的元素索引，如果不存在，返回-1
 * @param nums: 输入数组
 * @param target: 目标值
 * @return: 目标值索引
*/
int search(vector<int>& nums, int target){
    // 二分查找区间[left, right)，初始为整个区间
    int left = 0;   
    int right = nums.size();
    // 找到最后小于target的值
    while(left < right){
        int mid = left + ((right - left) >> 1);
        if(nums[mid] < target){
            left = mid + 1;  // 找到一个小于target的值，暂存并在右半区间继续查找更大的小于target的值
        }else{
            right = mid;    // 没有找到小于target的值，则在左半区间去寻找更小的数
        }
    }
    return left - 1;    // left始终为暂存结果的后一位
}
```
小结：
四种搜索策略，核心思路是一样的，关键在于：
确定搜索首个元素和最后元素是应该以哪个值作为目标值进行搜索；
确定搜索得到的结果是直接指向首个/最后元素，还是指向它们的相邻为；
大于/大于等于都是可以直接得到首个元素的位置，间接得到最后元素的位置（得到最后元素的后一位），区别在于搜索的值分别为 target - 1, target 和 target, target + 1。
小于/小于等于都是间接首个元素的位置【首个元素的前一位】，直接得到最后元素的位置，区别在于搜索的值分别为 target, target + 1 和 target - 1, target。

### 4. 最后小于等于目标值的搜索策略
```c++
/**
    * @brief 返回最后小于等于target的元素索引，如果不存在，返回-1
    * @param nums: 输入数组
    * @param target: 目标值
    * @return: 目标值索引
*/
int search(vector<int>& nums, int target){
    // 二分查找区间[left, right)，初始为整个区间
    int left = 0;   
    int right = nums.size();
    // 找到最后小于等于target的值
    while(left < right){
        int mid = left + ((right - left) >> 1);
        if(nums[mid] <= target){
            left = mid + 1;  // 找到一个小于等于target的值，暂存并在右半区间继续查找更大的小于target的值
        }else{
            right = mid;    // 没有找到小于等于target的值，则在左半区间去寻找更小的数
        }
    }
    return left - 1;    // left始终为暂存结果的后一位
}
```
## 朴素的二分查找
### 704. 二分查找 - 力扣（LeetCode）
给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。


示例 1:
```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```
示例 2:
```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```
```c++
class Solution
{
public:
	int search(std::vector<int> &nums, int target)
	{
		int i = 0;
		int j = nums.size() - 1;
		while (i <= j)
		{
			int mid = (i + j) / 2;
			int n = nums[mid];
			if (n == target)
			{
				return mid;
			}
			else if (n < target)
			{
				i = mid + 1;
			}
			else
			{
				j = mid - 1;
			}
		}
		return -1;
	}
};
```
## 二分查找查找边界
### 34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）
给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。

示例 1：
```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```
示例 2：
```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```
示例 3：
```
输入：nums = [], target = 0
输出：[-1,-1]
```
```c++
class Solution { 
public:
    int binarySearch(vector<int>& nums, int target, bool lower) {
        int left = 0, right = (int)nums.size() - 1, ans = (int)nums.size();
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > target || (lower && nums[mid] >= target)) {
                right = mid - 1;
                ans = mid;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        int leftIdx = binarySearch(nums, target, true);
        int rightIdx = binarySearch(nums, target, false) - 1;
        if (leftIdx <= rightIdx && rightIdx < nums.size() && nums[leftIdx] == target && nums[rightIdx] == target) {
            return vector<int>{leftIdx, rightIdx};
        } 
        return vector<int>{-1, -1};
    }
};
```
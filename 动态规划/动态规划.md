# 动态规划
动态规划是一种用于解决优化问题的算法策略。它将一个复杂的问题分解为一系列相互关联的子问题，通过求解子问题的最优解来构建原问题的最优解。其核心思想是利用子问题的重叠性质，避免重复计算，从而提高算法的效率
动态规划有三要素：初始状态，最终状态和方程式（状态方程式获得中间状态）2、动态规划一般用于：求有多少种方式，方法，路径；求最值：机器人从左到右的最大路径和；求存在性：有没有从左到右的一个路径可能

# 动态规划的解题步骤
* 定义状态：确定问题中的状态变量，状态是对问题在某一时刻或某一阶段的描述。例如，在计算斐波那契数列时，状态可以定义为第n项的值，用dp[n]表示。
* 确定状态转移方程：描述状态之间的转换关系。对于斐波那契数列，状态转移方程为:
    `dp[n] = dp[n-1] + dp[n-2]`
* 确定边界条件：即问题的初始状态。对于斐波那契数列，边界条件是dp[0] = 0, dp[1] = 1，

```c++
#include <iostream>
#include <vector>

// 自底向上的动态规划计算斐波那契数列
int fib(int n) {
    if (n == 0) {
        return 0;
    }
    std::vector<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```
## 示例
### 62. 不同路径 - 力扣（LeetCode）
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？

示例 1：
```
输入：m = 3, n = 7
输出：28
```
示例 2：
```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```
示例 3：
```
输入：m = 7, n = 3
输出：28
```
示例 4：
```
输入：m = 3, n = 3
输出：6
```

提示：
```
1 <= m, n <= 100
题目数据保证答案小于等于 2 * 109
```
思路：
```
到达在图中(i,j)点的路径数为它左侧和上方点的路径和
因此状态转移方程为 dp(i,j) = dp(i - 1,j) + dp(i,j-1)
且图的最左侧和最上层的路径只能为1
```
```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        std::vector<std::vector<int>> dp(m, std::vector<int>(n, 0));
		for (int i = 0; i < m; i++)
		{
			dp[i][0] = 1;
		}
		for (int j = 0; j < n; j++)
		{
			dp[0][j] = 1;
		}
		for (int i = 1; i < m; i++)
		{
			for (int j = 1; j < n; j++)
			{
				dp[i][j] = dp[i -1][j] + dp[i][j-1];
			}
		}
		return dp[m-1][n-1];
    }
};
```

### 121. 买卖股票的最佳时机 - 力扣（LeetCode）

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

示例 1：
```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```
示例 2：
```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

```c++
class Solution {
public:
	int maxProfit(vector<int>& prices) {
		int n = prices.size();
		std::vector<int> dp(n, 0);
		int minprices = prices[0];
		for (int i = 1; i < n; i++)
		{
			dp[i] = std::max(prices[i] - minprices, dp[i -1]);
			minprices = std::min(prices[i], minprices);
		}

		return dp[n-1];
	}
};
```

### 70. 爬楼梯 - 力扣（LeetCode）

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

示例 1：
```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```
示例 2：
```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

```c++
class Solution {
public:
    int climbStairs(int n) {
        if (n == 1 || n == 0)
        {
            return n;
        }
        std::vector<int> dp(n, 0);
        dp[0] = 1;
        dp[1] = 2;
        for (int i = 2; i < n; i++)
        {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n-1];
    }
};
```
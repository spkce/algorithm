给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组是数组中的一个连续部分。

示例 1：
```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```
示例 2：
```
输入：nums = [1]
输出：1
```
示例 3：
```
输入：nums = [5,4,-1,7,8]
输出：23
```
思路：
```
dp[i] 表示（0，i）子串最大和
可是 dp[i - 1] 有可能是负数，于是分类讨论：
如果 dp[i - 1] > 0，那么可以把 nums[i] 直接接在 dp[i - 1] 表示的那个数组的后面，得到和更大的连续子数组；
如果 dp[i - 1] <= 0，那么 nums[i] 加上前面的数 dp[i - 1] 以后值不会变大。于是 dp[i] 「另起炉灶」，此时单独的一个 nums[i] 的值，就是 dp[i]
状态转移方程：

dp = dp[i-1] + nums[i] , dp[i-1] > 0
     nums[i]           , dp[i-1] <= 0

最后遍历所有dp求出最大的值
```
```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        std::vector<int> dp(n);

        dp[0] = nums[0];
        for(int i = 1; i < n; i++)
        {
            if (dp[i-1] > 0)
            {
                dp[i] = nums[i] + dp[i - 1];
            }
            else
            {
                dp[i] = nums[i];
            }
        }

        int res = dp[0];
        for (int i = 1; i < n; i++)
        {
            res = std::max(res, dp[i]);
        }
        return res;
    }
};
```
# 并查集
并查集  (Disjoint Set) 是一种精巧而实用的数据结构,它主要用于处理一些不相交集合的合并问题。经典的应用有连通图,最小生成树Kruskal算法、最近公共祖先 (LeastCommonAncestors,LCA)等

## 并查集的基本操作
* 初始化

定义数组s[], s[i]门是元素i所属的并查集,开始时,还没有处理点与点之间的朋友关系,所以每个点属于独立的集,直接以元素i的值表示它的集s[i],如元素1的集s[1]=1
```
i:   1 2 3 4 5             
s[i]:1 2 3 4 5             
```
* 合并

加入第1个朋友关系(1,2)。在并查集s中,把节点1合并到节点2,也就是把节点1的集1.改为节点2的集2
```
i:   1 2 3 4 5
s[i]:2 2 3 4 5
```
加入第1个朋友关系(1,3)。查找节点1的集2,再递归查找节点2的集2然后把节点2的集2合并到节点3的集3,节点1、2、3都属于一个集
```
i:   1 2 3 4 5
s[i]:2 3 3 4 5
```
加入第3个朋友关系(2,4)
```
i:   1 2 3 4 5
s[i]:2 3 4 4 5
```

* 查找

上述步骤中已经有查找操作。查找元素的集,是一个递归的过程,直到元素的值和它的集相等,就找到了根节点的集。可以看到,这棵搜索树的高度可能很大,复杂度为  О(n),变成了一个链表,出现了树的“退化”现象。
* 统计

如果s[i]=i,这是一个根节点,是它所在的集的代表;统计根节点的数量,就是集的数量。

## 并查集的优化 (路径压缩)
在上面的查询函数中,查询元素主所属的集需要搜索路径找到根节点,返回的结果是根节点。这条搜索路径可能很长。如果在返回时顺便把i所属的集改为根节点，那么下次再搜时,就能在O(1)的时间内得到结果。
```
i:   1 2 3 4 5
s[i]:4 4 4 4 5
```
## 并查集的带秩合并
在并查集中，秩（rank）主要用于优化合并操作。秩可以简单理解为树（集合在并查集数据结构中可以看作是树的形式）的高度或者深度的一种近似表示。它的作用是尽量让较浅的树（集合）成为较深的树（集合）的子树，从而减少后续查找操作的时间复杂度。在理想情况下，通过合理的合并策略，能够使并查集的查找操作接近  的时间复杂度

## 模版
```c++
#include <vector>
using namespace std;
 
class UnionFind {
private:
    vector<int> parent, rank;
 
public:
    UnionFind(int n) {
        parent.resize(n);
        rank.resize(n, 0); //秩
        for (int i = 0; i < n; i++) {
            parent[i] = i;  // 初始时每个元素的父节点是自己
        }
    }
 
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // 路径压缩
        }
        return parent[x];
    }
 
    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            // 按秩合并
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX] += 1;
            }
        }
    }
};

int main() {
    UnionFind uf(10); // 10是节点的数量
    uf.unite(1, 2);   // 合并节点1和2
    uf.unite(2, 3);   // 合并节点2和3
    uf.unite(4, 5);   // 合并节点4和5
    // ...
 
    if (uf.find(1) == uf.find(5)) {
        cout << "节点1和节点5在同一个集合中" << endl;
    } else {
        cout << "节点1和节点5不在同一个集合中" << endl;
    }
    // ...
    return 0;
}
```
## 示例
### LCR 116. 省份数量 - 力扣（LeetCode）

有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。
省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。
给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。
返回矩阵中省份的数量。

示例 1：
```
输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
输出：2
```
示例 2：
```
输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]
输出：3
```
提示：
```
1 <= n <= 200
n == isConnected.length
n == isConnected[i].length
isConnected[i][j] 为 1 或 0
isConnected[i][i] == 1
isConnected[i][j] == isConnected[j][i]
```
```c++

class UnionFind {
public:
    vector<int> parent, rank;
 
public:
    UnionFind(int n) {
        parent.resize(n);
        rank.resize(n, 0); //秩
        for (int i = 0; i < n; i++) {
            parent[i] = i;  // 初始时每个元素的父节点是自己
        }
    }
 
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // 路径压缩
        }
        return parent[x];
    }
 
    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            // 按秩合并
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX] += 1;
            }
        }
    }
};

class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
		UnionFind uf(isConnected.size());

		for(int i = 0; i < isConnected.size(); i++)
		{
			for (int j = 0; j < isConnected[0].size();j++)
			{
				if(isConnected[i][j])
				{
					uf.unite(i, j);
				}
			}
		}
		int n = 0;
		for (int i = 0; i< uf.parent.size(); i++)
		{
			if (i == uf.parent[i])
			{
				n++;
			}
		}
		return n;
    }
};
```
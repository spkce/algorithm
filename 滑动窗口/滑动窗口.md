# 滑动窗口算法
滑动窗口算法是一种解决数组或列表中子数组或子序列问题的有效方法。该算法通过定义一个窗口，然后在数据结构上滑动该窗口，逐步处理数据，以解决特定类型的问题。其基本思想是维护一个窗口，初始时窗口覆盖数组中的一部分元素，然后通过滑动窗口来依次处理每个子数组。在每次窗口滑动时，可以通过添加新元素和删除旧元素来更新窗口的内容，以在O(1)时间内完成操作。
## 模版
```c++
//外层循环扩展右边界，内层循环扩展左边界
for (int l = 0, r = 0 ; r < n ; r++) {
	//当前考虑的元素
	while (l <= r && check()) {//区间[left,right]不符合题意
        //扩展左边界
    }
    //区间[left,right]符合题意，统计相关信息
}
```
### 209. 长度最小的子数组 - 力扣（LeetCode）
给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其总和大于等于 target 的长度最小的子数组
`[nums(l), nums(l+1), ..., nums(r-1), nums(r)]`，并返回其长度。如果不存在符合条件的子数组，返回 0 。

示例 1：
```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```
示例 2：
```
输入：target = 4, nums = [1,4,4]
输出：1
```
示例 3：
```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```
思路：
```
定义两个指针 start 和 end 分别表示子数组（滑动窗口窗口）的开始位置和结束位置，维护变量 sum 存储子数组中的元素和（即从 nums[start] 到 nums[end] 的元素和）。
初始状态下，start 和 end 都指向下标 0，sum 的值为 0。
每一轮迭代，将 nums[end] 加到 sum，如果 sum≥target，则更新子数组的最小长度（此时子数组的长度是 end−start+1），然后将 nums[start] 从 sum 中减去并将 start 右移，直到 sum<s，在此过程中同样更新子数组的最小长度。在每一轮迭代的最后，将 end 右移。
```

```c++
class Solution {
public:
	int minSubArrayLen(int target, std::vector<int>& nums) {
		int s = 0;
		int sum = 0;
		int min = nums.size() + 1;
		for (int e = 0; e < nums.size(); e++)
		{
			sum += nums[e];
			while (sum >= target)
			{
				min = std::min(e - s + 1, min);
				sum -= nums[s];
				s++;
			}
		}

		return min < nums.size() + 1 ? min : 0;
	}
};
```

### 3. 无重复字符的最长子串 - 力扣（LeetCode）

给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度。

示例 1:
```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```
示例 2:
```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```
示例 3:
```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```
```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        map<int, int> mMap; //map记录字符出现的位置
		int result = 0;
		int length = 0;
		int start = 0;
		for (int end = 0; end < s.size(); end++)
		{
			if (mMap.find(s[end]) != mMap.end() && mMap[s[end]] >= start)
			{
				start = mMap[s[end]] + 1;
				length = end - start;
			}

			length++;
			mMap[s[end]] = end;

			if (result < length)
			{
				result = length;
			}
		}
		return result;
    }
};
```
### 1456. 定长子串中元音的最大数目 - 力扣（LeetCode）

给你字符串 s 和整数 k 。
请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。
英文中的 元音字母 为（a, e, i, o, u）。

示例 1：
```
输入：s = "abciiidef", k = 3
输出：3
解释：子字符串 "iii" 包含 3 个元音字母。
```
示例 2：
```
输入：s = "aeiou", k = 2
输出：2
解释：任意长度为 2 的子字符串都包含 2 个元音字母。
```
示例 3：
```
输入：s = "leetcode", k = 3
输出：2
解释："lee"、"eet" 和 "ode" 都包含 2 个元音字母。
```
示例 4：
```
输入：s = "rhythms", k = 4
输出：0
解释：字符串 s 中不含任何元音字母。
```
示例 5：
```
输入：s = "tryhard", k = 4
输出：1
```


可以遍历字符串 s 每个长度为 k 的子串，求出其中包含的元音字母个数，并找出最大值。

对于任意一个子串，假设它的长度为 k，结束位置为 r，我们用 sk(r) 来表示。如果sk(r) 中包含了 x 个元音字母，那么下一个相同长度的字符串（结束位置为 k+1）包含的元音字母个数即为
```
sk(r+1) 包含元音字母的个数= x + (s[r+1] 为元音字母)−(s[r+1−k] 为元音字母)
```
也就是说，sk(r+1) 比 sk(r) 少了字母 s[r+1−k] 而多了字母 s[r+1]，因此上面的等式是成立的。
```c++
class Solution {
public:
    bool isVowel(char ch) {
        return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u'; 
    }
    
    int maxVowels(string s, int k) {
        int n = s.size();
        int vowel_count = 0;
        for (int i = 0; i < k; ++i) {
            vowel_count += isVowel(s[i]);
        }
        int ans = vowel_count;
        for (int i = k; i < n; ++i) {
            vowel_count += isVowel(s[i]) - isVowel(s[i - k]);
            ans = max(ans, vowel_count);
        }
        return ans;
    }
};
```